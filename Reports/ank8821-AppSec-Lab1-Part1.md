# Below are the steps taken to exploit
## For x86 Binary

### **1. Finding the value of ebp register and the offset.**
---
> `# gdb stack-L1-dgb`<br />
`# b bof`<br />
`# run`<br />
`# next`<br />

![](./Artifacts/x86/ank8821-screenshot7.png)

From the above image we find the memory address of the ebp register. Therefore the return address will be at 0xffffcae8 + 4. We also see that the ebp register is 108 places away from the starting address of the buffer. Therefore the distance of the start of buffer and the return address will be 108+4 = 112. This is how we find the inital value for our return address and the offset of 112.

### **2. Finding the value of start variable in the exploit.**
---
517 is the length of input that our program can take. The start variable can be set to the value of 517 - len(shellcode). We place the shellcode at the end of the bytearray so that we it does not overwrite our return address and our return address can easily point to anywhere in the NOP sled to lead right to our shellcode.

### **3. Running with inital values and finding the correct return address.**
---
We now use the following values:
- start = 517 - len(shellcode)
- ret = 0xffffcae8 + 120 (because the stack is deeper when program runs in degub mode)
- offset = 112

Running with the above values did not give us a shell because the return address is not correct. In order to find the correct address we add "\xdd\xdd\xdd\xdd" at the end of the shellcode. This will help us locate our shellcode easily when we debug.
>`gdb stack-L1`<br />
`b bof`<br />
`run`<br />
`searchmem 0xdddddddd`<br />
`x/8i <stack address of 0xdddddddd>-0x100`<br />

![](./Artifacts/x86/ank8821-screenshot6.png)

Here, we are trying to locate the memory address of our shellcode. `searchmem` will give us the stack address of 0xdddddddd and then we use `x/8i` to examine 8 addresses at a time as instructions and we start from 100 addresses before the address of 0xdddddddd. We then keep entering to run the same instruction until we find the start of our shell code.

![](./Artifacts/x86/ank8821-screenshot3.png)

Once the NOP Sled ends we know we have found the start of our shell code. We use that address as return address in our exploit to get a shell.

![](./Artifacts/x86/ank8821-screenshot4.png)

## Final Exploit for x86
---
![](./Artifacts/x86/ank8821-screenshot2.png)

![](./Artifacts/x86/ank8821-screenshot1.png)

## For x64 Binary
---
We follow all the same steps as above. We check the value of '`p $rbp`' because the ebp register is called rbp for 64 bit architecture.

![](./Artifacts/x64/ank8821-screenshot1.png)

Also the value of offset here will be 208 + 8 = 216 becuase the addresses are 8 bytes and not 4 like in 32 bit architecture.

![](./Artifacts/x64/ank8821-screenshot5.png)

![](./Artifacts/x64/ank8821-screenshot6.png)
![](./Artifacts/x64/ank8821-screenshot2.png)

## Final Exploit for x64
---
![](./Artifacts/x64/ank8821-screenshot3.png)
![](./Artifacts/x64/ank8821-screenshot4.png)